
from collections import defaultdict
def readData(path):
    """
    Parameters
    --------------------------
        path: path of database D.
         
    --------------------------
    Returns
        data: a dictionary for representing database D
                 - keys: transaction tids
                 - values: itemsets.
        s: support of distict items in D.
    """
    data={}
    s=defaultdict(lambda: 0) #* Initialize a dictionary for storing support of items in I.  
    with open(path,'rt') as f:
        tid=1
        for line in f:
            itemset=set(map(int,line.split())) #* A python set is a native way for storing an itemset.
            for item in itemset:  
                s[item]+=1     #* Why don't we compute support of items while reading data?
            data[tid]= itemset
            tid+=1
    return data, s
def joinset(a,b):
    '''
    Parameters
    -------------------
        2 itemsets a and b (of course they are at same branch in search space) 

    -------------------
    return 
        ret: itemset generated by joining a and b
    '''
    # a,b same brach -> a_k = b_k
    # temp = 
    return {'itemset':[a,b],'pruned':False,'support':0}
    # Hint: this function will be called in generateSearchSpace method.:
    

class TP:
    def __init__ (self, data=None, s=None, minSup=None):
        self.data=data
        self.s={}
        
        
        for key, support in sorted(s.items(),key= lambda item: item[1],reverse=True):
            self.s[key]=support
        # Why should we do this, answer it at the markdown below?
            
        self.minSup=minSup
        self.L={}  #Store frequent itemsets mined from database
        self.runAlgorithm()
    def initialize(self):
        """
        Initialize search space at first step
        --------------------------------------
        We represent our search space in a tree structure
        """
        tree={}

        search_space={}  
        for item, support in self.s.items():
            search_space[item]={}
            
            search_space[item]['itemset']=[item] 
            ''' 
            python set does not remain elements order
            so we use a list to extend it easily when create new itemset 
            but why we store itemset in data by a python set???? '''
            # TODO: study about python set and its advantages,
            # answer at the markdown below.
            
            search_space[item]['pruned']=False

            
            search_space[item]['support']=support
            
            tree[item]={}
            '''
            Why should i store an additional tree (here it called tree)? 
            Answer: This really help in next steps.
            
            Remember that there is always a big gap from theory to practicality
            and implementing this algorithm in python is not as simple as you think.
            ''' 
        
        return tree, search_space
    
    def sortData(self,data):
        sorted_data = dict(sorted(data.items(), key=lambda item: item[1]['support'], reverse=True))
        data=sorted_data

    def computeItemsetSupport(self, itemset):
        
        '''Return support of itemset'''
        # TODO (hint: this is why i use python set in data)
        support=0
        for key,set in self.data.items():
            for i in itemset:
                if i not in set:
                    continue
                support+=1
        return support
          
    def prune(self,k, tree, search_space):
        #get the value > minSup (3000)
        self.L[k]={}
        for key in tree.keys():
            sp=self.computeItemsetSupport(search_space[key]["itemset"])
            if search_space[key]["pruned"] == False:
                if(sp>=self.minSup):
                    self.L[k].update({key:search_space[key]})
                else:
                    search_space[key]["pruned"] = True
            search_space[key]["support"]=sp
        
        '''
        In this method we will find out which itemset in current search space is frequent 
        itemset then add it to L[k]. In addition, we prune those are not frequent itemsets. 
        '''
        #TODO

       
    def generateSearchSpace(self,k, tree, search_space):
        '''
        Generate search space for exploring k+1 itemset. (Recursive function) 
        '''
        items=list(tree.keys())  
        ''' print search_space.keys() you will understand  
         why we need an additional tree, '''
        l=len(items)
        self.prune(k, tree, search_space)
        if l==0: return   #Stop condition
        
        # self.sortData(search_space)
        for i in range(l-1):
            a=items[i]
            if search_space[a]['pruned']: continue 
                
            for j in range(i+1,l):
                b=items[j]
                
                search_space[a][b]={}
                tree[a][b]={}
                #TODO
                # You really need to understand what am i doing here before doing work below.
                # (Hint: draw tree and search space to draft). 
            
                #First create newset using join set
                join=joinset(a,b)
                
                #Second add newset to search_space
                search_space[a][b]=join
            
            #  Generate search_space for k+1-itemset
            self.generateSearchSpace(k+1,tree[a],search_space[a])

    
    def runAlgorithm(self):
        tree,search_space=self.initialize() #generate search space for 1-itemset
        self.generateSearchSpace(1, tree, search_space)
    def miningResults(self):
        return self.L
        
transactions, freq= readData('chess.txt')
a=TP(data=transactions,s=freq, minSup=3000)
print(*a.miningResults().items(),sep="\n")